substitutions:
  pin_heating_element: GPIO32
  pwm_period_heating_element: 5.0s
  pin_heating_element_feedback: GPIO21

  pid_kp: "0.15"
  pid_ki: "0.0"
  pid_kd: "0.0"

  timeout_to_idle: 5min

  power_idle: "1.0"
  power_heating: "962.0"

esphome:
  on_boot:
    then:
      - component.update: power
  on_loop:
    then:
      - script.execute: script_set_pid_mode

time:
  - platform: sntp

output:
  - platform: slow_pwm
    pin: ${pin_heating_element}
    id: heating_element
    period: ${pwm_period_heating_element}

select:
  - platform: template
    id: kettle_mode
    name: "${name_verbose} Mode"
    options:
      - idle
      - standby
      - heat up
      - heat up & hold
    update_interval: never
    optimistic: true
    initial_option: standby
    on_value:
      - if:
          condition:
            lambda: return !id(kettle_mode).state.compare("idle");
          then:
            - binary_sensor.template.publish:
                id: temperature_reached
                state: false
            - display.page.show:
                id: display_off
            - script.execute: timer_reset
          else:
            display.page.show:
              id: main_page

      - if:
          condition:
            lambda: return !id(kettle_mode).state.compare("standby");
          then:
            - binary_sensor.template.publish:
                id: temperature_reached
                state: false

interval:
  - interval: 10s
    then:
      if:
        condition:
          for:
            time: ${timeout_to_idle}
            condition:
              - lambda: return !id(kettle_mode).state.compare("standby");
              - not:
                  script.is_running: timer_start

        then:
          select.set:
            id: kettle_mode
            option: idle

climate:
  - platform: pid
    id: temperature_pid
    name: "${name_verbose} PID Controller"
    sensor: water_temperature
    default_target_temperature: 35
    heat_output: heating_element
    icon: mdi:kettle
    visual:
      min_temperature: 0.0
      max_temperature: 99.0
      temperature_step: 1.0
    control_parameters:
      kp: ${pid_kp}
      ki: ${pid_ki}
      kd: ${pid_kd}
    on_state:
      lambda: |-
        auto current_profile = id(profile).state;
        auto target_temperature = id(temperature_pid).target_temperature;
        if (!current_profile.compare("General") && target_temperature != id(profile_general_temperature))
          id(profile_general_temperature) = target_temperature;

binary_sensor:
  - platform: template
    id: temperature_reached
    name: "${name_verbose} Setpoint Reached"
    on_press:
      script.execute: rtttl_mario

  - platform: gpio
    id: heating_element_feedback
    pin: ${pin_heating_element_feedback}
    on_state:
      component.update: power

sensor:
  - platform: template
    name: "${name_verbose} Power"
    id: power
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      if (id(heating_element_feedback).state && id(power).state != ${power_heating}) {
        return ${power_heating};
      } else if (!id(heating_element_feedback).state && id(power).state != ${power_idle}) {
        return ${power_idle};
      } else {
        return {};
      }

  - platform: total_daily_energy
    name: "${name_verbose} Daily Energy"
    power_id: power
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    filters:
      multiply: 0.001

script:
  - id: script_set_pid_mode
    mode: single
    then:
      lambda: |-
        auto mode_call = id(kettle_mode).make_call();

        bool is_kettle_in_base = id(kettle_in_base).state;
        bool is_kettle_mode_active = id(kettle_mode).state.compare("standby") && id(kettle_mode).state.compare("idle");

        bool is_kettle_mode_hold = !id(kettle_mode).state.compare("heat up & hold");

        float target_temperature = id(temperature_pid).target_temperature;
        float current_temperature = id(temperature_pid).current_temperature;
        bool is_temperature_reached = current_temperature >= target_temperature;

        if (is_kettle_mode_active && is_temperature_reached && !id(temperature_reached).state) {
          id(temperature_reached).publish_state(true);
        }

        if (is_kettle_in_base && is_kettle_mode_active && !is_kettle_mode_hold && is_temperature_reached) {
          mode_call.set_option("standby");
          mode_call.perform();

          is_kettle_mode_active = id(kettle_mode).state.compare("standby") && id(kettle_mode).state.compare("idle");
        }

        bool is_pid_off = id(temperature_pid).mode == CLIMATE_MODE_OFF;

        auto pid_call = id(temperature_pid).make_call();
        if ((!is_kettle_in_base || !is_kettle_mode_active) && !is_pid_off) {
          pid_call.set_mode("OFF");
          pid_call.perform();

        } else if (is_kettle_in_base && is_kettle_mode_active && (!is_temperature_reached || is_kettle_mode_hold) && is_pid_off) {
          pid_call.set_mode("HEAT");
          pid_call.perform();

        }

        if (is_kettle_mode_active && !id(led_onoff).current_values.is_on()) {
          auto call = id(led_onoff).turn_on();
          call.perform();
        } else if (!is_kettle_mode_active && id(led_onoff).current_values.is_on()) {
          auto call = id(led_onoff).turn_off();
          call.perform();
        }

        if (is_kettle_mode_hold && !id(led_hold).current_values.is_on()) {
          auto call = id(led_hold).turn_on();
          call.perform();
        } else if (!is_kettle_mode_active && id(led_hold).current_values.is_on()) {
          auto call = id(led_hold).turn_off();
          call.perform();
        }

