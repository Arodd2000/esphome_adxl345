output:
  - platform: slow_pwm
    pin: GPIO32
    id: heating_element
    period: 5.0s

select:
  - platform: template
    id: kettle_mode
    name: "${name_verbose} Mode"
    options:
      - idle
      - standby
      - heat up
      - heat up & hold
    update_interval: never
    optimistic: true
    initial_option: standby

interval:
  - interval: 10s
    then:
      if:
        condition:
          for:
            time: 5min
            condition:
              lambda: return !id(kettle_mode).state.compare("standby");
        then:
          select.set:
            id: kettle_mode
            option: idle

climate:
  - platform: pid
    id: temperature_pid
    name: "${name_verbose} PID Controller"
    sensor: water_temperature
    default_target_temperature: 35
    heat_output: heating_element
    icon: mdi:kettle
    visual:
      min_temperature: 0.0
      max_temperature: 99.0
      temperature_step: 1.0
    control_parameters:
      kp: 0.45485
      ki: 0.09536
      kd: 0.54237
    on_state:
      lambda: |-
        auto current_profile = id(profile).state;
        auto target_temperature = id(temperature_pid).target_temperature;
        if (!current_profile.compare("General") && target_temperature != id(profile_general_temperature))
          id(profile_general_temperature) = target_temperature;

binary_sensor:
  - platform: template
    id: temperature_reached
    name: "${name_verbose} Setpoint Reached"

script:
  - id: script_set_pid_mode
    mode: single
    then:
      lambda: |-
        auto mode_call = id(kettle_mode).make_call();

        bool is_kettle_in_base = id(kettle_in_base).state;
        bool is_kettle_mode_active = id(kettle_mode).state.compare("standby") && id(kettle_mode).state.compare("idle");

        bool is_kettle_mode_hold = !id(kettle_mode).state.compare("heat up & hold");

        float target_temperature = id(temperature_pid).target_temperature;
        float current_temperature = id(temperature_pid).current_temperature;
        bool is_temperature_reached = current_temperature >= target_temperature;

        if (is_kettle_mode_active && is_temperature_reached) {
          id(temperature_reached).publish_state(true);
        }

        if (is_kettle_in_base && is_kettle_mode_active && !is_kettle_mode_hold && is_temperature_reached) {
          mode_call.set_option("standby");
          mode_call.perform();

          is_kettle_mode_active = id(kettle_mode).state.compare("standby") && id(kettle_mode).state.compare("idle");
        }

        bool is_pid_off = id(temperature_pid).mode == CLIMATE_MODE_OFF;

        auto pid_call = id(temperature_pid).make_call();
        if ((!is_kettle_in_base || !is_kettle_mode_active) && !is_pid_off) {
          pid_call.set_mode("OFF");
          pid_call.perform();

        } else if (is_kettle_in_base && is_kettle_mode_active && (!is_temperature_reached || is_kettle_mode_hold) && is_pid_off) {
          pid_call.set_mode("HEAT");
          pid_call.perform();

          if (id(temperature_reached).state)
            id(temperature_reached).publish_state(false);

        }

        if (is_kettle_mode_active && !id(led_onoff).current_values.is_on()) {
          auto call = id(led_onoff).turn_on();
          call.perform();
        } else if (!is_kettle_mode_active && id(led_onoff).current_values.is_on()) {
          auto call = id(led_onoff).turn_off();
          call.perform();
        }

        if (is_kettle_mode_hold && !id(led_hold).current_values.is_on()) {
          auto call = id(led_hold).turn_on();
          call.perform();
        } else if (!is_kettle_mode_active && id(led_hold).current_values.is_on()) {
          auto call = id(led_hold).turn_off();
          call.perform();
        }

