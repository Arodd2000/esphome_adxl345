binary_sensor:
  - platform: gpio
    id: button_onoff
    pin:
      number: GPIO05
      inverted: true
      mode:
        input: true
        pullup: true
    on_click:
      lambda: |-
        bool is_kettle_mode_active = id(kettle_mode).state.compare("standby");
        auto mode_call = id(kettle_mode).make_call();

        if (is_kettle_mode_active) {
          mode_call.set_option("standby");
          mode_call.perform();
        } else {
          mode_call.set_option("heat up & hold");
          mode_call.perform();
        }
    on_press:
      then:
        - delay: 1s
        - if:
           condition:
             for:
               time: 1s
               condition:
                 binary_sensor.is_on: button_onoff
           then:
             select.set:
               id: kettle_mode
               option: idle

  - platform: gpio
    id: button_hold
    pin:
      number: GPIO018
      inverted: true
      mode:
        input: true
        pullup: true
    on_click:
      lambda: |-
        bool is_kettle_mode_hold = !id(kettle_mode).state.compare("heat up & hold");
        auto mode_call = id(kettle_mode).make_call();

        if (!is_kettle_mode_hold) {
          mode_call.set_option("heat up & hold");
          mode_call.perform();
        } else {
          mode_call.set_option("heat up");
          mode_call.perform();
        }

  - platform: gpio
    id: button_menu
    pin:
      number: GPIO13
      inverted: true
      mode:
        input: true
        pullup: true
    on_click:
      lambda: |-
        auto options = id(profile).traits.get_options();
        auto current = id(profile).state;

        auto index = find(options.begin(), options.end(), current);

        index++;

        auto call = id(profile).make_call();
        if (index == options.end())
          call.set_option(*options.begin());
        else
          call.set_option(*index);
        call.perform();
    on_press:
      then:
        - delay: 400ms
        - if:
           condition:
             for:
               time: 400ms
               condition:
                 binary_sensor.is_on: button_menu
           then:
             select.set:
               id: profile
               option: General

  - platform: gpio
    id: button_timer
    pin:
      number: GPIO26
      inverted: true
      mode:
        input: true
        pullup: true

  - platform: gpio
    id: button_plus
    pin:
      number: GPIO19
      inverted: true
      mode:
        input: true
        pullup: true
    on_click:
      lambda: |-
        auto pid_call = id(temperature_pid).make_call();
        float current = id(temperature_pid).target_temperature;
        float max_temperature = id(temperature_pid).get_traits().get_visual_max_temperature();
        float next_temperature_step = current + 1.0;
        float new_temperature = min(next_temperature_step, max_temperature);
        pid_call.set_target_temperature(new_temperature);
        pid_call.perform();

  - platform: gpio
    id: button_minus
    pin:
      number: GPIO23
      inverted: true
      mode:
        input: true
        pullup: true
    on_click:
      lambda: |-
        auto pid_call = id(temperature_pid).make_call();
        float current = id(temperature_pid).target_temperature;
        float min_temperature = id(temperature_pid).get_traits().get_visual_min_temperature();
        float next_temperature_step = current - 1.0;
        float new_temperature = max(next_temperature_step, min_temperature);
        pid_call.set_target_temperature(new_temperature);
        pid_call.perform();

interval:
  - interval: 333ms
    then:
      if:
        condition:
          for:
            time: 1s
            condition:
              binary_sensor.is_on: button_plus
        then:
          lambda: |-
            auto pid_call = id(temperature_pid).make_call();
            float current = id(temperature_pid).target_temperature;
            float max_temperature = id(temperature_pid).get_traits().get_visual_max_temperature();
            float next_temperature_step = current - ((int)current % 5) + 5.0;
            float new_temperature = min(next_temperature_step, max_temperature);
            pid_call.set_target_temperature(new_temperature);
            pid_call.perform();

  - interval: 333ms
    then:
      if:
        condition:
          for:
            time: 1s
            condition:
              binary_sensor.is_on: button_minus
        then:
          lambda: |-
            auto pid_call = id(temperature_pid).make_call();
            float current = id(temperature_pid).target_temperature;
            float min_temperature = id(temperature_pid).get_traits().get_visual_min_temperature();
            float next_temperature_step = min_temperature;
            if ((int)current % 5) {
              next_temperature_step = current - ((int)current % 5);
            } else {
              next_temperature_step = current - 5.0;
            }
            float new_temperature = max(next_temperature_step, min_temperature);
            pid_call.set_target_temperature(new_temperature);
            pid_call.perform();

