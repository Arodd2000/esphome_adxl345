substitutions:
  pin_display_i2c_sda: GPIO25
  pin_display_i2c_scl: GPIO22
  period_display_icons: "2500"

i2c:
  id: display_i2c
  sda: ${pin_display_i2c_sda}
  scl: ${pin_display_i2c_scl}
  scan: false
  frequency: 800kHz

font:
  - file: 'packages/fonts/dogicapixel.ttf'
    id: ttf8
    size: 8
  - file: 'packages/fonts/dogicapixel.ttf'
    id: ttf12
    size: 12
  - file: 'packages/fonts/dogicapixel.ttf'
    id: ttf24
    size: 24

image:
  - file: 'packages/icons/thermometer-alert-whitebg.png'
    id: icon_thermometer_alert
  - file: 'packages/icons/thermometer-chevron-up-whitebg.png'
    id: icon_thermometer_heating
  - file: 'packages/icons/thermometer-high-whitebg.png'
    id: icon_thermometer_high

  - file: 'packages/icons/battery-alert-variant-outline-whitebg.png'
    id: icon_battery_alert

  - file: 'packages/icons/timer-outline-whitebg.png'
    id: icon_timer

  - file: 'packages/icons/home-assistant-whitebg.png'
    id: icon_home_assistant

  - file: 'packages/icons/wifi-alert-whitebg.png'
    id: icon_wifi_alert

  - file: 'packages/icons/kettle-outline-whitebg.png'
    id: icon_kettle_outline

display:
  - platform: ssd1306_i2c
    id: main_display
    i2c_id: display_i2c
    model: "SH1106 128x64"
    update_interval: 500ms
    pages:
      - id: kettle_disconnected
        lambda: |-
          it.print(63, 16, id(ttf12), TextAlign::TOP_CENTER, "Kettle not");
          it.print(63, 50, id(ttf12), TextAlign::BOTTOM_CENTER, "connected!");

      - id: main_page
        lambda: |-
          if (id(water_temperature).has_state() && !isnan(id(water_temperature).state))
            it.printf(2, 14, id(ttf24), TextAlign::TOP_LEFT, "%.0f", id(water_temperature).state);
          else
            it.print(18, 14, id(ttf12), TextAlign::TOP_LEFT, "-");

          it.print(42, 14, id(ttf12), TextAlign::TOP_LEFT, "°C");

          it.printf(64, 23, id(ttf12), TextAlign::TOP_LEFT, "%.0f", id(temperature_pid).target_temperature);
          it.print(86, 23, id(ttf8), TextAlign::TOP_LEFT, "°C");

          it.print(126, 12, id(ttf8), TextAlign::TOP_RIGHT, id(profile).state.c_str());

          bool pid_active = id(temperature_pid).mode != CLIMATE_MODE_OFF;
          bool heating_element_active = id(heating_element_feedback).state;

          std::vector<std::pair<int, Image*>> icons = {};

          if (heating_element_active) {
            icons.push_back(std::make_pair(1, id(icon_thermometer_heating)));

          } else if (id(temperature_reached).state) {
            icons.push_back(std::make_pair(1, id(icon_thermometer_alert)));

          } else if (pid_active && !heating_element_active) {
            icons.push_back(std::make_pair(1, id(icon_thermometer_high)));

          } else {
            icons.push_back(std::make_pair(1, nullptr));

          }

          if (id(battery_level_low).state)
            icons.push_back(std::make_pair(3, id(icon_battery_alert)));

          int time_to_display = 0;
          if (id(timer_active).state || id(timer_value).state != 0.0)
            time_to_display = (int)id(timer_value).state;
          else
            time_to_display = (int)id(timer_default_value).state;

          int minutes = time_to_display / 60;
          int seconds = time_to_display % 60;
          it.printf(2, 54, id(ttf12), TextAlign::BOTTOM_LEFT, "%02i:%02i", minutes, seconds);

          if (id(timer_reached).state) {
            icons.push_back(std::make_pair(1, id(icon_timer)));

            if (id(timer_active).state) {
              it.print(50, 54, id(ttf12), TextAlign::BOTTOM_LEFT, "+");
            }
          }

          if (!id(native_api).is_connected())
            icons.push_back(std::make_pair(1, id(icon_home_assistant)));

          if (!id(wifi_component).is_connected())
            icons.push_back(std::make_pair(1, id(icon_wifi_alert)));

          if (id(ble_kettle).state() != esphome::esp32_ble_tracker::ClientState::ESTABLISHED)
            icons.push_back(std::make_pair(1, id(icon_kettle_outline)));

          int slices_required = 0;
          for (auto ic = icons.begin(); ic != icons.end(); ic++) {
            slices_required += ic->first;
          }

          int current_slice = (millis() / (${period_display_icons} / slices_required)) % slices_required;

          int slice_offset = 0;
          for (auto ic = icons.begin(); ic != icons.end(); ic++) {
            slice_offset += ic->first;
            if (current_slice < slice_offset) {
              if (ic->second)
                it.image(102, 28, ic->second);
              break;
            }
          }

      - id: display_off
        lambda: ''

