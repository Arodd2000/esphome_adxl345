i2c:
  id: display_i2c
  sda: GPIO25
  scl: GPIO22
  scan: false
  frequency: 800kHz

font:
  - file: 'dogicapixel.ttf'
    id: ttf8
    size: 8
  - file: 'dogicapixel.ttf'
    id: ttf12
    size: 12
  - file: 'dogicapixel.ttf'
    id: ttf24
    size: 24

image:
  - file: 'icons/thermometer-alert-whitebg.png'
    id: icon_thermometer_alert
  - file: 'icons/thermometer-chevron-up-whitebg.png'
    id: icon_thermometer_heating
  - file: 'icons/thermometer-high-whitebg.png'
    id: icon_thermometer_high

  - file: 'icons/battery-alert-variant-outline-whitebg.png'
    id: icon_battery_alert

  - file: 'icons/timer-outline-whitebg.png'
    id: icon_timer

display:
  - platform: ssd1306_i2c
    id: main_display
    i2c_id: display_i2c
    model: "SH1106 128x64"
    update_interval: 500ms
    pages:
      - id: kettle_disconnected
        lambda: |-
          it.print(63, 16, id(ttf12), TextAlign::TOP_CENTER, "Kettle not");
          it.print(63, 50, id(ttf12), TextAlign::BOTTOM_CENTER, "connected!");

      - id: main_page
        lambda: |-
          if (id(water_temperature).has_state() && !isnan(id(water_temperature).state))
            it.printf(2, 14, id(ttf24), TextAlign::TOP_LEFT, "%.0f", id(water_temperature).state);
          else
            it.print(18, 14, id(ttf12), TextAlign::TOP_LEFT, "-");

          it.print(42, 14, id(ttf12), TextAlign::TOP_LEFT, "°C");

          it.printf(64, 23, id(ttf12), TextAlign::TOP_LEFT, "%.0f", id(temperature_pid).target_temperature);
          it.print(86, 23, id(ttf8), TextAlign::TOP_LEFT, "°C");

          it.print(126, 12, id(ttf8), TextAlign::TOP_RIGHT, id(profile).state.c_str());

          bool pid_active = id(temperature_pid).mode != CLIMATE_MODE_OFF;
          bool heating_element_active = id(heating_element_feedback).state;

          std::vector<std::pair<int, Image*>> icons = {};

          if (heating_element_active) {
            icons.push_back(std::make_pair(1, id(icon_thermometer_heating)));

          } else if (id(temperature_reached).state) {
            icons.push_back(std::make_pair(1, id(icon_thermometer_alert)));

          } else if (pid_active && !heating_element_active) {
            icons.push_back(std::make_pair(1, id(icon_thermometer_high)));

          } else {
            icons.push_back(std::make_pair(1, nullptr));

          }

          if (id(ble_battery_level).state < 30.0)
            icons.push_back(std::make_pair(3, id(icon_battery_alert)));

          int time_to_display = 0;
          if (id(timer_start).is_running() || id(timer_value).state != 0.0)
            time_to_display = (int)id(timer_value).state;
          else
            time_to_display = (int)id(timer_default_value).state;


          int minutes = time_to_display / 60;
          int seconds = time_to_display % 60;
          it.printf(2, 54, id(ttf12), TextAlign::BOTTOM_LEFT, "%02i:%02i", minutes, seconds);

          if (id(timer_reached).state)
            icons.push_back(std::make_pair(1, id(icon_timer)));

          int slices_required = 0;
          for (auto ic = icons.begin(); ic != icons.end(); ic++) {
            slices_required += ic->first;
          }

          int current_slice = (millis() / (2500 / slices_required)) % slices_required;

          int slice_offset = 0;
          for (auto ic = icons.begin(); ic != icons.end(); ic++) {
            slice_offset += ic->first;
            if (current_slice < slice_offset) {
              if (ic->second)
                it.image(102, 28, ic->second);
              break;
            }
          }

      - id: display_off
        lambda: ''

